{{!

  Copyright 2016 Facebook, Inc.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.

}}{{!

Python wrappers of the structs defined in the services files. This file is
compiled into it's own module to be included by clients and services and
end-user code. It's one of the more complicated files, as it has to map
Pythonic APIs to C++ objects and back.

One of the nastier things in this file is the definition of containers.
A separate container wrapper has to be defined for each type of contained
attribute because Cython can't template C++ classes. So, for example, we need
a List__int16 or a List__string or a Map__string_mystruct instance for each
container/type combination. Consider that containers can contain other containers
or structs that contain containers and you realize how messy this can get.
Further, we'd prefer to have the end user freed from having to know about these
container types, so we'll need to define factories for them based on what they
want to include.

}}
{{> common/AutoGeneratedPy}}

from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint32_t
from cython.operator cimport dereference as deref, preincrement as inc
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types import NOTSET
from thrift.py3.types cimport translate_cpp_enum_to_python
cimport thrift.py3.std_libcpp as std_libcpp
from thrift.py3.serializer cimport IOBuf
from thrift.py3.serializer import Protocol
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize

import sys
from collections.abc import Sequence, Set, Mapping, Iterable
from enum import Enum
{{#program:includeNamespaces}}
{{#hasTypes?}}
cimport {{#includeNamespace}}{{value}}.{{/includeNamespace}}types
import {{#includeNamespace}}{{value}}.{{/includeNamespace}}types
{{/hasTypes?}}
{{/program:includeNamespaces}}


{{#program:enums}}
class {{enum:name}}(Enum):
    {{#enum:values}}
    {{enumValue:name}} = <int> ({{enum:name}}__{{enumValue:name}})
    {{/enum:values}}

cdef c{{enum:name}} {{enum:name}}_to_cpp(value):
    {{#enum:values}}
    {{^first?}}el{{/first?}}if value == {{enum:name}}.{{enumValue:name}}:
        return {{enum:name}}__{{enumValue:name}}
    {{/enum:values}}
{{/program:enums}}


{{#program:structs}}
{{^struct:union?}}
{{^struct:exception?}}
cdef c{{struct:name}} _{{struct:name}}_defaults = c{{struct:name}}()

{{/struct:exception?}}
cdef class {{struct:name}}{{#struct:exception?}}(thrift.py3.exceptions.Error){{/struct:exception?}}{{^struct:exception?}}(thrift.py3.types.Struct){{/struct:exception?}}:

    def __init__(
        {{struct:name}} self{{#struct:fields}},
        {{field:name}}=None{{/struct:fields}}
    ):
        self._cpp_obj = move({{struct:name}}._make_instance(
          NULL,{{#struct:fields}}
          {{field:name}},{{/struct:fields}}
        ))

    {{^struct:exception?}}
    def __call__(
        {{struct:name}} self{{#struct:fields}},
        {{field:name}}=NOTSET{{/struct:fields}}
    ):
        changes = any(({{#struct:fields}}
            {{field:name}} is not NOTSET,
            {{/struct:fields}}
        ))

        if not changes:
            return self

        inst = <{{struct:name}}>{{struct:name}}.__new__({{struct:name}})
        inst._cpp_obj = move({{struct:name}}._make_instance(
          self._cpp_obj.get(),{{#struct:fields}}
          {{field:name}},{{/struct:fields}}
        ))
        return inst
    {{/struct:exception?}}

    @staticmethod
    cdef unique_ptr[c{{struct:name}}] _make_instance(
        c{{struct:name}}* base_instance{{#struct:fields}},
        object {{field:name}}{{/struct:fields}}
    ) except *:
        cdef unique_ptr[c{{struct:name}}] c_inst
        if base_instance:
            c_inst = make_unique[c{{struct:name}}](deref(base_instance))
        else:
            c_inst = make_unique[c{{struct:name}}]()

        {{! We never have a base_instance for exceptions (because they have
            no __call__, so don't generate this part for them because it
            references the _defaults object, which they also don't have )}}
        {{^struct:exception?}}
        if base_instance:
            # Convert None's to default value.
            {{#struct:fields}}
            if {{field:name}} is None:
                {{#field:reference?}}
                raise ValueError("Reference-annotated fields may not be initialized to defaults")
                {{/field:reference?}}{{!
                }}{{^field:reference?}}
                deref(c_inst).{{field:name}} = _{{struct:name}}_defaults.{{field:name}}
                {{^field:required?}}
                deref(c_inst).__isset.{{field:name}} = False
                {{/field:required?}}{{!
                }}{{/field:reference?}}
            elif {{field:name}} is NOTSET:
                {{field:name}} = None

            {{/struct:fields}}{{!
            }}{{^struct:fields}}
            pass
            {{/struct:fields}}
        {{/struct:exception?}}
        {{#struct:fields}}{{#field:type}}
        if {{field:name}} is not None:
            {{> CythonAssignField}}

            {{! This should also be inside the if statement, so indent appropriately }}
            {{^field:required?}}{{^field:reference?}}
            deref(c_inst).__isset.{{field:name}} = True

            {{/field:reference?}}{{/field:required?}}
        {{/field:type}}{{/struct:fields}}
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        {{#struct:fields}}
        yield '{{field:name}}', self.{{field:name}}
        {{/struct:fields}}
        {{^struct:fields}}
        return iter(())
        {{/struct:fields}}

    def __bool__(self):
        return {{#struct:fields}}{{!
            }}{{#field:required?}}True{{/field:required?}}{{!
            }}{{^field:required?}}{{!
            }}{{#field:reference?}}<bint>(deref(self._cpp_obj).{{field:name}}){{/field:reference?}}{{!
            }}{{^field:reference?}}{{!
            }}deref(self._cpp_obj).__isset.{{field:name}}{{!
            }}{{/field:reference?}}{{/field:required?}}{{!
            }}{{^last?}} or {{/last?}}{{/struct:fields}}{{!
            }}{{^struct:fields}}True{{/struct:fields}}

    @staticmethod
    cdef create(shared_ptr[c{{struct:name}}] cpp_obj):
        inst = <{{struct:name}}>{{struct:name}}.__new__({{struct:name}})
        inst._cpp_obj = cpp_obj
        return inst

    {{#struct:fields}}
    @property
    def {{field:name}}(self):
        {{#field:type}}
        {{^field:value}}
        {{^field:required?}}{{^field:reference?}}
        {{! If there is no value and not ___isset we can say it's None}}
        if not deref(self._cpp_obj).__isset.{{field:name}}:
            return None

        {{/field:reference?}}{{/field:required?}}
        {{/field:value}}
        {{> CythonStructGetter}}

        {{/field:type}}

    {{/struct:fields}}

    def __hash__({{struct:name}} self):
        {{^struct:exception?}}
        if not self.__hash:
            self.__hash = hash((
            {{#struct:fields}}
            self.{{field:name}},
            {{/struct:fields}}
            {{^struct:fields}}
            type(self)   # Hash the class there are no fields
            {{/struct:fields}}
            ))
        return self.__hash
        {{/struct:exception?}}
        {{#struct:exception?}}
        return super().__hash__()
        {{/struct:exception?}}

    def __repr__({{struct:name}} self):
        return f'{{struct:name}}({{#struct:fields}}{{field:name}}={repr(self.{{field:name}})}{{^last?}}, {{/last?}}{{/struct:fields}})'
{{/struct:union?}}{{!
}}{{#struct:union?}}
class {{struct:name}}Type(Enum):
    EMPTY = <int>c{{struct:name}}__type___EMPTY__
{{#struct:fields}}{{#field:type}}
    {{field:name}} = <int>c{{struct:name}}__type_{{field:name}}
{{/field:type}}{{/struct:fields}}

cdef class {{struct:name}}(thrift.py3.types.Struct):
    def __init__(
        {{struct:name}} self{{#struct:fields}},
        {{field:name}}=None{{/struct:fields}}
    ):
        self._cpp_obj = move({{struct:name}}._make_instance(
          NULL,{{#struct:fields}}
          {{field:name}},{{/struct:fields}}
        ))
        self._load_cache()

    @staticmethod
    cdef unique_ptr[c{{struct:name}}] _make_instance(
        c{{struct:name}}* base_instance{{#struct:fields}},
        {{field:name}}{{/struct:fields}}
    ) except *:
        cdef unique_ptr[c{{struct:name}}] c_inst = make_unique[c{{struct:name}}]()
        cdef bint any_set = False
        {{#struct:fields}}{{#field:type}}
        if {{field:name}} is not None:
            if any_set:
                raise ValueError("At most one field may be set when initializing a union")
            {{> CythonUnionAssignField}}

            any_set = True
        {{/field:type}}{{/struct:fields}}
        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __bool__(self):
        return self.__type != {{struct:name}}Type.EMPTY

    @staticmethod
    cdef create(shared_ptr[c{{struct:name}}] cpp_obj):
        inst = <{{struct:name}}>{{struct:name}}.__new__({{struct:name}})
        inst._cpp_obj = cpp_obj
        inst._load_cache()
        return inst

    {{#struct:fields}}
    @property
    def {{field:name}}(self):
        if self.__type != {{struct:name}}Type.{{field:name}}:
            raise ValueError(f'Union contains a value of type {self.__type.name}, not {{field:name}}')
        return self.__cached

    {{/struct:fields}}

    def __hash__({{struct:name}} self):
        if not self.__hash:
            self.__hash = hash((
                self.__type,
                self.__cached,
            ))
        return self.__hash

    def __repr__({{struct:name}} self):
        return f'{{struct:name}}(type={self.__type.name}, value={repr(self.__cached)})'

    cdef _load_cache({{struct:name}} self):
        if self.__type is not None:
            return

        self.__type = {{struct:name}}Type(<int>(deref(self._cpp_obj).getType()))
        if self.__type == {{struct:name}}Type.EMPTY:
            self.__cached = None
        {{#struct:fields}}{{#field:type}}
        elif self.__type == {{struct:name}}Type.{{field:name}}:
            {{> CythonUnionGetter}}

        {{/field:type}}{{/struct:fields}}

    def get_type({{struct:name}} self):
        return self.__type

{{/struct:union?}}
    {{! Below are some things that are common to structs and unions: }}
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, {{struct:name}}) and
                isinstance(other, {{struct:name}})):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef c{{struct:name}} cself = deref((<{{struct:name}}>self)._cpp_obj)
        cdef c{{struct:name}} cother = deref((<{{struct:name}}>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    {{^struct:exception?}}
    cdef bytes _serialize({{struct:name}} self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[c{{struct:name}}](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[c{{struct:name}}](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[c{{struct:name}}](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize({{struct:name}} self, const IOBuf* buf, proto):
        cdef uint32_t needed
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[c{{struct:name}}](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[c{{struct:name}}](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[c{{struct:name}}](buf, deref(self._cpp_obj.get()))
        {{#struct:union?}}
        # force a cache reload since the underlying data's changed
        self.__type = None
        self._load_cache()
        {{/struct:union?}}
        return needed

    def __reduce__(self):
        return (deserialize, ({{struct:name}}, serialize(self)))
    {{/struct:exception?}}


{{/program:structs}}
{{#program:containerTypes}}
cdef class {{type:flat_name}}:
    def __init__(self, items=None):
        if isinstance(items, {{type:flat_name}}):
            self._cpp_obj = (<{{type:flat_name}}> items)._cpp_obj
        else:
            self._cpp_obj = move({{type:flat_name}}._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[{{> types/CythonCppType}}] c_items):
        inst = <{{type:flat_name}}>{{type:flat_name}}.__new__({{type:flat_name}})
        inst._cpp_obj = c_items
        return inst

{{#type:list?}}
    @staticmethod
    cdef unique_ptr[{{> types/CythonCppType}}] _make_instance(object items) except *:
        cdef unique_ptr[{{> types/CythonCppType}}] c_inst = make_unique[{{> types/CythonCppType}}]()
        if items:
            for item in items:
                deref(c_inst).push_back({{#type:listElemType}}{{!
                    }}{{> CythonPythonToCppItem}}{{/type:listElemType}})
        return move_unique(c_inst)

    def __getitem__(self, object index_obj):
        cdef int index
        cdef shared_ptr[{{> types/CythonCppType}}] c_inst
        cdef {{#type:listElemType}}{{> types/CythonCppType}}{{/type:listElemType}} citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[{{> types/CythonCppType}}]()
            start_val = index_obj.start
            stop_val = index_obj.stop
            step_val = index_obj.step
            sz = deref(self._cpp_obj).size()

            if step_val == 0 or step_val is None:
                step_val = 1
            if step_val > 0:
                if start_val is None:
                    start_val = 0
                elif start_val > sz:
                    start_val = sz
                if stop_val is None:
                    stop_val = sz
                elif stop_val > sz:
                    stop_val = sz
            else:
                if start_val is None:
                    start_val = sz - 1
                elif start_val > sz - 1:
                    start_val = sz - 1
                if stop_val is None:
                    stop_val = -1
                elif stop_val > sz - 1:
                    stop_val = sz - 1

            index = start_val
            while ((step_val > 0 and index < stop_val) or
                   (step_val < 0 and index > stop_val)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
                index += step_val
            return {{type:flat_name}}.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size - index
            if index >= size:
                raise IndexError('list index out of range')
            # Support negative indexes
            if index < 0:
                index = size - index
            {{#type:listElemType}}
            citem = deref(self._cpp_obj.get())[index]
            return {{> ContainerCythonCppToPythonItem}}
            {{/type:listElemType}}

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef {{#type:listElemType}}{{!
          }}{{> types/CythonCppType}} citem = {{!
          }}{{> CythonPythonToCppItem}}{{/type:listElemType}}
        cdef {{> types/CythonCppType}} vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef {{#type:listElemType}}{{!
            }}{{>types/CythonCppType}}{{!
            }}{{/type:listElemType}} citem
        for citem in deref(self._cpp_obj):
            yield {{#type:listElemType}}{{!
                }}{{> ContainerCythonCppToPythonItem}}{{!
                }}{{/type:listElemType}}

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef {{#type:listElemType}}{{!
            }}{{>types/CythonCppType}}{{!
            }}{{/type:listElemType}} citem
        cdef {{> types/CythonCppType}} vec = deref(
            self._cpp_obj.get())
        cdef {{>types/CythonCppType}}.reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield {{#type:listElemType}}{{!
                }}{{> ContainerCythonCppToPythonItem}}{{!
                }}{{/type:listElemType}}
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef {{#type:listElemType}}{{!
            }}{{> types/CythonCppType}} citem = {{!
            }}{{> CythonPythonToCppItem}}{{/type:listElemType}}
        cdef {{> types/CythonCppType}} vec = {{!
            }}deref(self._cpp_obj.get())
        cdef {{>types/CythonCppType}}.iterator loc = {{!
            }}std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef {{#type:listElemType}}{{!
            }}{{> types/CythonCppType}} citem = {{!
            }}{{> CythonPythonToCppItem}}{{/type:listElemType}}
        cdef {{> types/CythonCppType}} vec = {{!
            }}deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register({{type:flat_name}})
{{/type:list?}}
{{#type:set?}}
    @staticmethod
    cdef unique_ptr[{{> types/CythonCppType}}] _make_instance(object items) except *:
        cdef unique_ptr[{{> types/CythonCppType}}] c_inst = make_unique[{{> types/CythonCppType}}]()
        if items:
            for item in items:
                deref(c_inst).insert({{#type:setElemType}}{{!
                    }}{{> CythonPythonToCppItem}}{{/type:setElemType}})
        return move_unique(c_inst)

    def __contains__(self, item):
        if not self:
            return False
        return pbool(deref(self._cpp_obj).count({{#type:setElemType}}{{>CythonPythonToCppItem}}{{/type:setElemType}}))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield {{#type:setElemType}}{{> ContainerCythonCppToPythonItem}}{{/type:setElemType}}

    def __repr__(self):
    {{=<% %>=}}
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'
    <%={{ }}=%>

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef {{> types/CythonCppType}} cself, cother
        cdef cbool retval
        if (isinstance(self, {{type:flat_name}}) and
                isinstance(other, {{type:flat_name}})):
            cself = deref((<{{type:flat_name}}> self)._cpp_obj)
            cother = deref((<{{type:flat_name}}> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, {{type:flat_name}}):
            self = {{type:flat_name}}(self)
        if not isinstance(other, {{type:flat_name}}):
            other = {{type:flat_name}}(other)

        cdef shared_ptr[{{> types/CythonCppType}}] shretval = \
            make_shared[{{> types/CythonCppType}}]()
        for citem in deref((<{{type:flat_name}}> self)._cpp_obj):
            if deref((<{{type:flat_name}}> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return {{type:flat_name}}.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, {{type:flat_name}}):
            self = {{type:flat_name}}(self)
        if not isinstance(other, {{type:flat_name}}):
            other = {{type:flat_name}}(other)

        cdef shared_ptr[{{> types/CythonCppType}}] shretval = \
            make_shared[{{> types/CythonCppType}}]()
        for citem in deref((<{{type:flat_name}}> self)._cpp_obj):
            if deref((<{{type:flat_name}}> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return {{type:flat_name}}.create(shretval)

    def __or__(self, other):
        if not isinstance(self, {{type:flat_name}}):
            self = {{type:flat_name}}(self)
        if not isinstance(other, {{type:flat_name}}):
            other = {{type:flat_name}}(other)

        cdef shared_ptr[{{> types/CythonCppType}}] shretval = \
            make_shared[{{> types/CythonCppType}}]()
        for citem in deref((<{{type:flat_name}}> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<{{type:flat_name}}> other)._cpp_obj):
                deref(shretval).insert(citem)
        return {{type:flat_name}}.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, {{type:flat_name}}):
            self = {{type:flat_name}}(self)
        if not isinstance(other, {{type:flat_name}}):
            other = {{type:flat_name}}(other)

        cdef shared_ptr[{{> types/CythonCppType}}] shretval = \
            make_shared[{{> types/CythonCppType}}]()
        for citem in deref((<{{type:flat_name}}> self)._cpp_obj):
            if deref((<{{type:flat_name}}> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<{{type:flat_name}}> other)._cpp_obj):
            if deref((<{{type:flat_name}}> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return {{type:flat_name}}.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register({{type:flat_name}})
{{/type:set?}}
{{#type:map?}}
    @staticmethod
    cdef unique_ptr[{{> types/CythonCppType}}] _make_instance(object items) except *:
        cdef unique_ptr[{{> types/CythonCppType}}] c_inst = make_unique[{{> types/CythonCppType}}]()
        if items:
            for key, item in items.items():
                deref(c_inst).insert(cpair[{{!
                    }}{{#type:keyType}}{{> types/CythonCppType}}{{/type:keyType}},{{!
                    }}{{#type:valueType}}{{> types/CythonCppType}}{{/type:valueType}}{{!
                    }}]({{!
                    }}{{#type:keyType}}{{> CythonPythonToCppKey}}{{/type:keyType}},{{!
                    }}{{#type:valueType}}{{> CythonPythonToCppItem}}{{/type:valueType}}))
        return move_unique(c_inst)

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef {{#type:keyType}}{{> types/CythonCppType}} ckey = {{!
            }}{{> CythonPythonToCppKey}}{{/type:keyType}}
        cdef {{> types/CythonCppType}}.iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef {{#type:valueType}}{{!
            }}{{> types/CythonCppType}} {{!
            }}citem = deref(iter).second{{/type:valueType}}
        return {{#type:valueType}}{{!
            }}{{> ContainerCythonCppToPythonItem}}{{/type:valueType}}

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef {{#type:keyType}}{{!
            }}{{> types/CythonCppType}}{{/type:keyType}} citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield {{#type:keyType}}{{!
                }}{{> ContainerCythonCppToPythonItem}}{{/type:keyType}}

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
    {{=<% %>=}}
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'
    <%={{ }}=%>



    def __contains__(self, key):
        cdef {{#type:keyType}}{{!
            }}{{> types/CythonCppType}} ckey = {{!
            }}{{> CythonPythonToCppKey}}{{/type:keyType}}
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef {{#type:keyType}}{{!
            }}{{> types/CythonCppType}} ckey = {{!
            }}{{> CythonPythonToCppKey}}{{/type:keyType}}
        cdef {{> types/CythonCppType}}.iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef {{#type:valueType}}{{!
            }}{{> types/CythonCppType}} citem = {{!
            }}deref(iter).second{{/type:valueType}}
        return {{#type:valueType}}{{!
          }}{{> ContainerCythonCppToPythonItem}}{{!
          }}{{/type:valueType}}

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef {{#type:valueType}}{{!
          }}{{> types/CythonCppType}}{{!
          }}{{/type:valueType}}{{!!
          }} citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield {{#type:valueType}}{{!
              }}{{> ContainerCythonCppToPythonItem}}{{!
              }}{{/type:valueType}}

    def items(self):
        if not self:
            raise StopIteration
        cdef {{#type:keyType}}{{!
          }}{{> types/CythonCppType}}{{!
          }}{{/type:keyType}}{{!
          }} ckey
        cdef {{#type:valueType}}{{!
          }}{{> types/CythonCppType}}{{!
          }}{{/type:valueType}} citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield ({{!
              }}{{#type:keyType}}{{!
              }}{{> ContainerCythonCppToPythonKey}}{{!
              }}{{/type:keyType}}, {{!
              }}{{#type:valueType}}{{!
              }}{{> ContainerCythonCppToPythonItem}}{{!
              }}{{/type:valueType}})



Mapping.register({{type:flat_name}})
{{/type:map?}}

{{/program:containerTypes}}{{!
}}{{#program:constants}}
{{#constant:value}}{{> ConstantValue}}{{/constant:value}}{{/program:constants}}{{!
}}{{#program:typedefs}}
{{typedef:symbolic}} = {{#typedef:type}}{{> types/CythonPythonType}}{{/typedef:type}}
{{/program:typedefs}}

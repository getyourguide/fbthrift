#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#  @generated
#

from libcpp.memory cimport shared_ptr, make_shared, unique_ptr, make_unique
from libcpp.string cimport string
from libcpp cimport bool as cbool
from libcpp.iterator cimport inserter as cinserter
from cpython cimport bool as pbool
from libc.stdint cimport int8_t, int16_t, int32_t, int64_t, uint32_t
from cython.operator cimport dereference as deref, preincrement as inc
import thrift.py3.types
cimport thrift.py3.types
cimport thrift.py3.exceptions
from thrift.py3.types import NOTSET
from thrift.py3.types cimport translate_cpp_enum_to_python
cimport thrift.py3.std_libcpp as std_libcpp
from thrift.py3.serializer cimport IOBuf
from thrift.py3.serializer import Protocol
cimport thrift.py3.serializer as serializer
from thrift.py3.serializer import deserialize, serialize

import sys
from collections.abc import Sequence, Set, Mapping, Iterable
from enum import Enum


class has_bitwise_ops(Enum):
    none = <int> (has_bitwise_ops__none)
    zero = <int> (has_bitwise_ops__zero)
    one = <int> (has_bitwise_ops__one)
    two = <int> (has_bitwise_ops__two)
    three = <int> (has_bitwise_ops__three)

cdef chas_bitwise_ops has_bitwise_ops_to_cpp(value):
    if value == has_bitwise_ops.none:
        return has_bitwise_ops__none
    elif value == has_bitwise_ops.zero:
        return has_bitwise_ops__zero
    elif value == has_bitwise_ops.one:
        return has_bitwise_ops__one
    elif value == has_bitwise_ops.two:
        return has_bitwise_ops__two
    elif value == has_bitwise_ops.three:
        return has_bitwise_ops__three


cdef cdecorated_struct _decorated_struct_defaults = cdecorated_struct()

cdef class decorated_struct(thrift.py3.types.Struct):

    def __init__(
        decorated_struct self,
        field=None
    ):
        self._cpp_obj = move(decorated_struct._make_instance(
          NULL,
          field,
        ))

    def __call__(
        decorated_struct self,
        field=NOTSET
    ):
        changes = any((
            field is not NOTSET,
        ))

        if not changes:
            return self

        inst = <decorated_struct>decorated_struct.__new__(decorated_struct)
        inst._cpp_obj = move(decorated_struct._make_instance(
          self._cpp_obj.get(),
          field,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cdecorated_struct] _make_instance(
        cdecorated_struct* base_instance,
        object field
    ) except *:
        cdef unique_ptr[cdecorated_struct] c_inst
        if base_instance:
            c_inst = make_unique[cdecorated_struct](deref(base_instance))
        else:
            c_inst = make_unique[cdecorated_struct]()

        if base_instance:
            # Convert None's to default value.
            if field is None:
                deref(c_inst).field = _decorated_struct_defaults.field
                deref(c_inst).__isset.field = False
            elif field is NOTSET:
                field = None

        if field is not None:
            deref(c_inst).field = field.encode('UTF-8')
            deref(c_inst).__isset.field = True

        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'field', self.field

    def __bool__(self):
        return deref(self._cpp_obj).__isset.field

    @staticmethod
    cdef create(shared_ptr[cdecorated_struct] cpp_obj):
        inst = <decorated_struct>decorated_struct.__new__(decorated_struct)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def field(self):
        if not deref(self._cpp_obj).__isset.field:
            return None

        return self._cpp_obj.get().field.decode('UTF-8')


    def __hash__(decorated_struct self):
        if not self.__hash:
            self.__hash = hash((
            self.field,
            ))
        return self.__hash

    def __repr__(decorated_struct self):
        return f'decorated_struct(field={repr(self.field)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, decorated_struct) and
                isinstance(other, decorated_struct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cdecorated_struct cself = deref((<decorated_struct>self)._cpp_obj)
        cdef cdecorated_struct cother = deref((<decorated_struct>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(decorated_struct self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cdecorated_struct](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cdecorated_struct](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cdecorated_struct](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(decorated_struct self, const IOBuf* buf, proto):
        cdef uint32_t needed
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cdecorated_struct](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cdecorated_struct](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cdecorated_struct](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (decorated_struct, serialize(self)))


cdef cContainerStruct _ContainerStruct_defaults = cContainerStruct()

cdef class ContainerStruct(thrift.py3.types.Struct):

    def __init__(
        ContainerStruct self,
        fieldA=None,
        fieldB=None,
        fieldC=None,
        fieldD=None,
        fieldE=None,
        fieldF=None,
        fieldG=None
    ):
        self._cpp_obj = move(ContainerStruct._make_instance(
          NULL,
          fieldA,
          fieldB,
          fieldC,
          fieldD,
          fieldE,
          fieldF,
          fieldG,
        ))

    def __call__(
        ContainerStruct self,
        fieldA=NOTSET,
        fieldB=NOTSET,
        fieldC=NOTSET,
        fieldD=NOTSET,
        fieldE=NOTSET,
        fieldF=NOTSET,
        fieldG=NOTSET
    ):
        changes = any((
            fieldA is not NOTSET,

            fieldB is not NOTSET,

            fieldC is not NOTSET,

            fieldD is not NOTSET,

            fieldE is not NOTSET,

            fieldF is not NOTSET,

            fieldG is not NOTSET,
        ))

        if not changes:
            return self

        inst = <ContainerStruct>ContainerStruct.__new__(ContainerStruct)
        inst._cpp_obj = move(ContainerStruct._make_instance(
          self._cpp_obj.get(),
          fieldA,
          fieldB,
          fieldC,
          fieldD,
          fieldE,
          fieldF,
          fieldG,
        ))
        return inst

    @staticmethod
    cdef unique_ptr[cContainerStruct] _make_instance(
        cContainerStruct* base_instance,
        object fieldA,
        object fieldB,
        object fieldC,
        object fieldD,
        object fieldE,
        object fieldF,
        object fieldG
    ) except *:
        cdef unique_ptr[cContainerStruct] c_inst
        if base_instance:
            c_inst = make_unique[cContainerStruct](deref(base_instance))
        else:
            c_inst = make_unique[cContainerStruct]()

        if base_instance:
            # Convert None's to default value.
            if fieldA is None:
                deref(c_inst).fieldA = _ContainerStruct_defaults.fieldA
                deref(c_inst).__isset.fieldA = False
            elif fieldA is NOTSET:
                fieldA = None

            if fieldB is None:
                deref(c_inst).fieldB = _ContainerStruct_defaults.fieldB
                deref(c_inst).__isset.fieldB = False
            elif fieldB is NOTSET:
                fieldB = None

            if fieldC is None:
                deref(c_inst).fieldC = _ContainerStruct_defaults.fieldC
                deref(c_inst).__isset.fieldC = False
            elif fieldC is NOTSET:
                fieldC = None

            if fieldD is None:
                deref(c_inst).fieldD = _ContainerStruct_defaults.fieldD
                deref(c_inst).__isset.fieldD = False
            elif fieldD is NOTSET:
                fieldD = None

            if fieldE is None:
                deref(c_inst).fieldE = _ContainerStruct_defaults.fieldE
                deref(c_inst).__isset.fieldE = False
            elif fieldE is NOTSET:
                fieldE = None

            if fieldF is None:
                deref(c_inst).fieldF = _ContainerStruct_defaults.fieldF
                deref(c_inst).__isset.fieldF = False
            elif fieldF is NOTSET:
                fieldF = None

            if fieldG is None:
                deref(c_inst).fieldG = _ContainerStruct_defaults.fieldG
                deref(c_inst).__isset.fieldG = False
            elif fieldG is NOTSET:
                fieldG = None

        if fieldA is not None:
            deref(c_inst).fieldA = <vector[int32_t]>deref(List__i32(fieldA)._cpp_obj)
            deref(c_inst).__isset.fieldA = True

        if fieldB is not None:
            deref(c_inst).fieldB = <std_list[int32_t]>deref(std_list__List__i32(fieldB)._cpp_obj)
            deref(c_inst).__isset.fieldB = True

        if fieldC is not None:
            deref(c_inst).fieldC = <std_deque[int32_t]>deref(std_deque__List__i32(fieldC)._cpp_obj)
            deref(c_inst).__isset.fieldC = True

        if fieldD is not None:
            deref(c_inst).fieldD = <folly_fbvector[int32_t]>deref(folly_fbvector__List__i32(fieldD)._cpp_obj)
            deref(c_inst).__isset.fieldD = True

        if fieldE is not None:
            deref(c_inst).fieldE = <folly_small_vector[int32_t]>deref(folly_small_vector__List__i32(fieldE)._cpp_obj)
            deref(c_inst).__isset.fieldE = True

        if fieldF is not None:
            deref(c_inst).fieldF = <folly_sorted_vector_set[int32_t]>deref(folly_sorted_vector_set__Set__i32(fieldF)._cpp_obj)
            deref(c_inst).__isset.fieldF = True

        if fieldG is not None:
            deref(c_inst).fieldG = <folly_sorted_vector_map[int32_t,string]>deref(folly_sorted_vector_map__Map__i32_string(fieldG)._cpp_obj)
            deref(c_inst).__isset.fieldG = True

        # in C++ you don't have to call move(), but this doesn't translate
        # into a C++ return statement, so you do here
        return move_unique(c_inst)

    def __iter__(self):
        yield 'fieldA', self.fieldA
        yield 'fieldB', self.fieldB
        yield 'fieldC', self.fieldC
        yield 'fieldD', self.fieldD
        yield 'fieldE', self.fieldE
        yield 'fieldF', self.fieldF
        yield 'fieldG', self.fieldG

    def __bool__(self):
        return deref(self._cpp_obj).__isset.fieldA or deref(self._cpp_obj).__isset.fieldB or deref(self._cpp_obj).__isset.fieldC or deref(self._cpp_obj).__isset.fieldD or deref(self._cpp_obj).__isset.fieldE or deref(self._cpp_obj).__isset.fieldF or deref(self._cpp_obj).__isset.fieldG

    @staticmethod
    cdef create(shared_ptr[cContainerStruct] cpp_obj):
        inst = <ContainerStruct>ContainerStruct.__new__(ContainerStruct)
        inst._cpp_obj = cpp_obj
        return inst

    @property
    def fieldA(self):
        if not deref(self._cpp_obj).__isset.fieldA:
            return None

        if self.__fieldA is None:
            self.__fieldA = List__i32.create(make_shared[vector[int32_t]](deref(self._cpp_obj).fieldA))
        return self.__fieldA

    @property
    def fieldB(self):
        if not deref(self._cpp_obj).__isset.fieldB:
            return None

        if self.__fieldB is None:
            self.__fieldB = std_list__List__i32.create(make_shared[std_list[int32_t]](deref(self._cpp_obj).fieldB))
        return self.__fieldB

    @property
    def fieldC(self):
        if not deref(self._cpp_obj).__isset.fieldC:
            return None

        if self.__fieldC is None:
            self.__fieldC = std_deque__List__i32.create(make_shared[std_deque[int32_t]](deref(self._cpp_obj).fieldC))
        return self.__fieldC

    @property
    def fieldD(self):
        if not deref(self._cpp_obj).__isset.fieldD:
            return None

        if self.__fieldD is None:
            self.__fieldD = folly_fbvector__List__i32.create(make_shared[folly_fbvector[int32_t]](deref(self._cpp_obj).fieldD))
        return self.__fieldD

    @property
    def fieldE(self):
        if not deref(self._cpp_obj).__isset.fieldE:
            return None

        if self.__fieldE is None:
            self.__fieldE = folly_small_vector__List__i32.create(make_shared[folly_small_vector[int32_t]](deref(self._cpp_obj).fieldE))
        return self.__fieldE

    @property
    def fieldF(self):
        if not deref(self._cpp_obj).__isset.fieldF:
            return None

        if self.__fieldF is None:
            self.__fieldF = folly_sorted_vector_set__Set__i32.create(make_shared[folly_sorted_vector_set[int32_t]](deref(self._cpp_obj).fieldF))
        return self.__fieldF

    @property
    def fieldG(self):
        if not deref(self._cpp_obj).__isset.fieldG:
            return None

        if self.__fieldG is None:
            self.__fieldG = folly_sorted_vector_map__Map__i32_string.create(make_shared[folly_sorted_vector_map[int32_t,string]](deref(self._cpp_obj).fieldG))
        return self.__fieldG


    def __hash__(ContainerStruct self):
        if not self.__hash:
            self.__hash = hash((
            self.fieldA,
            self.fieldB,
            self.fieldC,
            self.fieldD,
            self.fieldE,
            self.fieldF,
            self.fieldG,
            ))
        return self.__hash

    def __repr__(ContainerStruct self):
        return f'ContainerStruct(fieldA={repr(self.fieldA)}, fieldB={repr(self.fieldB)}, fieldC={repr(self.fieldC)}, fieldD={repr(self.fieldD)}, fieldE={repr(self.fieldE)}, fieldF={repr(self.fieldF)}, fieldG={repr(self.fieldG)})'
    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(self, other))
        if not (
                isinstance(self, ContainerStruct) and
                isinstance(other, ContainerStruct)):
            if cop == 2:  # different types are never equal
                return False
            else:         # different types are always notequal
                return True

        cdef cContainerStruct cself = deref((<ContainerStruct>self)._cpp_obj)
        cdef cContainerStruct cother = deref((<ContainerStruct>other)._cpp_obj)
        cdef cbool cmp = cself == cother
        if cop == 2:
            return cmp
        return not cmp

    cdef bytes _serialize(ContainerStruct self, proto):
        cdef string c_str
        if proto is Protocol.COMPACT:
            serializer.CompactSerialize[cContainerStruct](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.BINARY:
            serializer.BinarySerialize[cContainerStruct](deref(self._cpp_obj.get()), &c_str)
        elif proto is Protocol.JSON:
            serializer.JSONSerialize[cContainerStruct](deref(self._cpp_obj.get()), &c_str)
        return <bytes> c_str

    cdef uint32_t _deserialize(ContainerStruct self, const IOBuf* buf, proto):
        cdef uint32_t needed
        if proto is Protocol.COMPACT:
            needed = serializer.CompactDeserialize[cContainerStruct](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.BINARY:
            needed = serializer.BinaryDeserialize[cContainerStruct](buf, deref(self._cpp_obj.get()))
        elif proto is Protocol.JSON:
            needed = serializer.JSONDeserialize[cContainerStruct](buf, deref(self._cpp_obj.get()))
        return needed

    def __reduce__(self):
        return (deserialize, (ContainerStruct, serialize(self)))


cdef class List__i32:
    def __init__(self, items=None):
        if isinstance(items, List__i32):
            self._cpp_obj = (<List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[vector[int32_t]] c_items):
        inst = <List__i32>List__i32.__new__(List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[vector[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[vector[int32_t]] c_inst = make_unique[vector[int32_t]]()
        if items:
            for item in items:
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __getitem__(self, object index_obj):
        cdef int index
        cdef shared_ptr[vector[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[vector[int32_t]]()
            start_val = index_obj.start
            stop_val = index_obj.stop
            step_val = index_obj.step
            sz = deref(self._cpp_obj).size()

            if step_val == 0 or step_val is None:
                step_val = 1
            if step_val > 0:
                if start_val is None:
                    start_val = 0
                elif start_val > sz:
                    start_val = sz
                if stop_val is None:
                    stop_val = sz
                elif stop_val > sz:
                    stop_val = sz
            else:
                if start_val is None:
                    start_val = sz - 1
                elif start_val > sz - 1:
                    start_val = sz - 1
                if stop_val is None:
                    stop_val = -1
                elif stop_val > sz - 1:
                    stop_val = sz - 1

            index = start_val
            while ((step_val > 0 and index < stop_val) or
                   (step_val < 0 and index > stop_val)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
                index += step_val
            return List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size - index
            if index >= size:
                raise IndexError('list index out of range')
            # Support negative indexes
            if index < 0:
                index = size - index
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef vector[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef vector[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._cpp_obj.get())
        cdef vector[int32_t].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef int32_t citem = item
        cdef vector[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(List__i32)

cdef class std_list__List__i32:
    def __init__(self, items=None):
        if isinstance(items, std_list__List__i32):
            self._cpp_obj = (<std_list__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(std_list__List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[std_list[int32_t]] c_items):
        inst = <std_list__List__i32>std_list__List__i32.__new__(std_list__List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[std_list[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[std_list[int32_t]] c_inst = make_unique[std_list[int32_t]]()
        if items:
            for item in items:
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __getitem__(self, object index_obj):
        cdef int index
        cdef shared_ptr[std_list[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[std_list[int32_t]]()
            start_val = index_obj.start
            stop_val = index_obj.stop
            step_val = index_obj.step
            sz = deref(self._cpp_obj).size()

            if step_val == 0 or step_val is None:
                step_val = 1
            if step_val > 0:
                if start_val is None:
                    start_val = 0
                elif start_val > sz:
                    start_val = sz
                if stop_val is None:
                    stop_val = sz
                elif stop_val > sz:
                    stop_val = sz
            else:
                if start_val is None:
                    start_val = sz - 1
                elif start_val > sz - 1:
                    start_val = sz - 1
                if stop_val is None:
                    stop_val = -1
                elif stop_val > sz - 1:
                    stop_val = sz - 1

            index = start_val
            while ((step_val > 0 and index < stop_val) or
                   (step_val < 0 and index > stop_val)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
                index += step_val
            return std_list__List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size - index
            if index >= size:
                raise IndexError('list index out of range')
            # Support negative indexes
            if index < 0:
                index = size - index
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef int32_t citem = item
        cdef std_list[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef std_list[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef std_list[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef int32_t citem = item
        cdef std_list[int32_t] vec = deref(self._cpp_obj.get())
        cdef std_list[int32_t].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef int32_t citem = item
        cdef std_list[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(std_list__List__i32)

cdef class std_deque__List__i32:
    def __init__(self, items=None):
        if isinstance(items, std_deque__List__i32):
            self._cpp_obj = (<std_deque__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(std_deque__List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[std_deque[int32_t]] c_items):
        inst = <std_deque__List__i32>std_deque__List__i32.__new__(std_deque__List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[std_deque[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[std_deque[int32_t]] c_inst = make_unique[std_deque[int32_t]]()
        if items:
            for item in items:
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __getitem__(self, object index_obj):
        cdef int index
        cdef shared_ptr[std_deque[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[std_deque[int32_t]]()
            start_val = index_obj.start
            stop_val = index_obj.stop
            step_val = index_obj.step
            sz = deref(self._cpp_obj).size()

            if step_val == 0 or step_val is None:
                step_val = 1
            if step_val > 0:
                if start_val is None:
                    start_val = 0
                elif start_val > sz:
                    start_val = sz
                if stop_val is None:
                    stop_val = sz
                elif stop_val > sz:
                    stop_val = sz
            else:
                if start_val is None:
                    start_val = sz - 1
                elif start_val > sz - 1:
                    start_val = sz - 1
                if stop_val is None:
                    stop_val = -1
                elif stop_val > sz - 1:
                    stop_val = sz - 1

            index = start_val
            while ((step_val > 0 and index < stop_val) or
                   (step_val < 0 and index > stop_val)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
                index += step_val
            return std_deque__List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size - index
            if index >= size:
                raise IndexError('list index out of range')
            # Support negative indexes
            if index < 0:
                index = size - index
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef int32_t citem = item
        cdef std_deque[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef std_deque[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef std_deque[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef int32_t citem = item
        cdef std_deque[int32_t] vec = deref(self._cpp_obj.get())
        cdef std_deque[int32_t].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef int32_t citem = item
        cdef std_deque[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(std_deque__List__i32)

cdef class folly_fbvector__List__i32:
    def __init__(self, items=None):
        if isinstance(items, folly_fbvector__List__i32):
            self._cpp_obj = (<folly_fbvector__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(folly_fbvector__List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[folly_fbvector[int32_t]] c_items):
        inst = <folly_fbvector__List__i32>folly_fbvector__List__i32.__new__(folly_fbvector__List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[folly_fbvector[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[folly_fbvector[int32_t]] c_inst = make_unique[folly_fbvector[int32_t]]()
        if items:
            for item in items:
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __getitem__(self, object index_obj):
        cdef int index
        cdef shared_ptr[folly_fbvector[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[folly_fbvector[int32_t]]()
            start_val = index_obj.start
            stop_val = index_obj.stop
            step_val = index_obj.step
            sz = deref(self._cpp_obj).size()

            if step_val == 0 or step_val is None:
                step_val = 1
            if step_val > 0:
                if start_val is None:
                    start_val = 0
                elif start_val > sz:
                    start_val = sz
                if stop_val is None:
                    stop_val = sz
                elif stop_val > sz:
                    stop_val = sz
            else:
                if start_val is None:
                    start_val = sz - 1
                elif start_val > sz - 1:
                    start_val = sz - 1
                if stop_val is None:
                    stop_val = -1
                elif stop_val > sz - 1:
                    stop_val = sz - 1

            index = start_val
            while ((step_val > 0 and index < stop_val) or
                   (step_val < 0 and index > stop_val)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
                index += step_val
            return folly_fbvector__List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size - index
            if index >= size:
                raise IndexError('list index out of range')
            # Support negative indexes
            if index < 0:
                index = size - index
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef int32_t citem = item
        cdef folly_fbvector[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef folly_fbvector[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef folly_fbvector[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef int32_t citem = item
        cdef folly_fbvector[int32_t] vec = deref(self._cpp_obj.get())
        cdef folly_fbvector[int32_t].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef int32_t citem = item
        cdef folly_fbvector[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(folly_fbvector__List__i32)

cdef class folly_small_vector__List__i32:
    def __init__(self, items=None):
        if isinstance(items, folly_small_vector__List__i32):
            self._cpp_obj = (<folly_small_vector__List__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(folly_small_vector__List__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[folly_small_vector[int32_t]] c_items):
        inst = <folly_small_vector__List__i32>folly_small_vector__List__i32.__new__(folly_small_vector__List__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[folly_small_vector[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[folly_small_vector[int32_t]] c_inst = make_unique[folly_small_vector[int32_t]]()
        if items:
            for item in items:
                deref(c_inst).push_back(item)
        return move_unique(c_inst)

    def __getitem__(self, object index_obj):
        cdef int index
        cdef shared_ptr[folly_small_vector[int32_t]] c_inst
        cdef int32_t citem
        if isinstance(index_obj, slice):
            c_inst = make_shared[folly_small_vector[int32_t]]()
            start_val = index_obj.start
            stop_val = index_obj.stop
            step_val = index_obj.step
            sz = deref(self._cpp_obj).size()

            if step_val == 0 or step_val is None:
                step_val = 1
            if step_val > 0:
                if start_val is None:
                    start_val = 0
                elif start_val > sz:
                    start_val = sz
                if stop_val is None:
                    stop_val = sz
                elif stop_val > sz:
                    stop_val = sz
            else:
                if start_val is None:
                    start_val = sz - 1
                elif start_val > sz - 1:
                    start_val = sz - 1
                if stop_val is None:
                    stop_val = -1
                elif stop_val > sz - 1:
                    stop_val = sz - 1

            index = start_val
            while ((step_val > 0 and index < stop_val) or
                   (step_val < 0 and index > stop_val)):
                citem = deref(self._cpp_obj.get())[index]
                deref(c_inst).push_back(citem)
                index += step_val
            return folly_small_vector__List__i32.create(c_inst)
        else:
            index = <int?>index_obj
            size = len(self)
            # Convert a negative index
            if index < 0:
                index = size - index
            if index >= size:
                raise IndexError('list index out of range')
            # Support negative indexes
            if index < 0:
                index = size - index
            citem = deref(self._cpp_obj.get())[index]
            return citem

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Iterable) and isinstance(other, Iterable)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for one, two in zip(self, other):
            if one != two:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __contains__(self, item):
        if not self:
            return False
        cdef int32_t citem = item
        cdef folly_small_vector[int32_t] vec = deref(
            self._cpp_obj.get())
        return std_libcpp.find(vec.begin(), vec.end(), citem) != vec.end()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'i[]'
        return f'i[{", ".join(map(repr, self))}]'

    def __reversed__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        cdef folly_small_vector[int32_t] vec = deref(
            self._cpp_obj.get())
        cdef folly_small_vector[int32_t].reverse_iterator loc = vec.rbegin()
        while loc != vec.rend():
            citem = deref(loc)
            yield citem
            inc(loc)

    def index(self, item):
        if not self:
            raise ValueError(f'{item} is not in list')
        cdef int32_t citem = item
        cdef folly_small_vector[int32_t] vec = deref(self._cpp_obj.get())
        cdef folly_small_vector[int32_t].iterator loc = std_libcpp.find(vec.begin(), vec.end(), citem)
        if loc != vec.end():
            return <int64_t> std_libcpp.distance(vec.begin(), loc)
        raise ValueError(f'{item} is not in list')

    def count(self, item):
        if not self:
            return 0
        cdef int32_t citem = item
        cdef folly_small_vector[int32_t] vec = deref(self._cpp_obj.get())
        return <int64_t> std_libcpp.count(vec.begin(), vec.end(), citem)


Sequence.register(folly_small_vector__List__i32)

cdef class folly_sorted_vector_set__Set__i32:
    def __init__(self, items=None):
        if isinstance(items, folly_sorted_vector_set__Set__i32):
            self._cpp_obj = (<folly_sorted_vector_set__Set__i32> items)._cpp_obj
        else:
            self._cpp_obj = move(folly_sorted_vector_set__Set__i32._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[folly_sorted_vector_set[int32_t]] c_items):
        inst = <folly_sorted_vector_set__Set__i32>folly_sorted_vector_set__Set__i32.__new__(folly_sorted_vector_set__Set__i32)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[folly_sorted_vector_set[int32_t]] _make_instance(object items) except *:
        cdef unique_ptr[folly_sorted_vector_set[int32_t]] c_inst = make_unique[folly_sorted_vector_set[int32_t]]()
        if items:
            for item in items:
                deref(c_inst).insert(item)
        return move_unique(c_inst)

    def __contains__(self, item):
        if not self:
            return False
        return pbool(deref(self._cpp_obj).count(item))

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        for citem in deref(self._cpp_obj):
            yield citem

    def __repr__(self):
        if not self:
            return 'iset()'
        return f'i{{{", ".join(map(repr, self))}}}'

    def __richcmp__(self, other, op):
        cdef int cop = op
        cdef folly_sorted_vector_set[int32_t] cself, cother
        cdef cbool retval
        if (isinstance(self, folly_sorted_vector_set__Set__i32) and
                isinstance(other, folly_sorted_vector_set__Set__i32)):
            cself = deref((<folly_sorted_vector_set__Set__i32> self)._cpp_obj)
            cother = deref((<folly_sorted_vector_set__Set__i32> other)._cpp_obj)
            # C level comparisons
            if cop == 0:    # Less Than (strict subset)
                if not cself.size() < cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 1:  # Less Than or Equal To  (subset)
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 2:  # Equivalent
                if cself.size() != cother.size():
                    return False
                for item in cself:
                    if not cother.count(item):
                        return False
                return True
            elif cop == 3:  # Not Equivalent
                for item in cself:
                    if not cother.count(item):
                        return True
                return cself.size() != cother.size()
            elif cop == 4:  # Greater Than (strict superset)
                if not cself.size() > cother.size():
                    return False
                for item in cother:
                    if not cself.count(item):
                        return False
                return True
            elif cop == 5:  # Greater Than or Equal To (superset)
                for item in cother:
                    if not cself.count(item):
                        return False
                return True

        # Python level comparisons
        if cop == 0:
            return Set.__lt__(self, other)
        elif cop == 1:
            return Set.__le__(self, other)
        elif cop == 2:
            return Set.__eq__(self, other)
        elif cop == 3:
            return Set.__ne__(self, other)
        elif cop == 4:
            return Set.__gt__(self, other)
        elif cop == 5:
            return Set.__ge__(self, other)

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self))
        return self.__hash

    def __and__(self, other):
        if not isinstance(self, folly_sorted_vector_set__Set__i32):
            self = folly_sorted_vector_set__Set__i32(self)
        if not isinstance(other, folly_sorted_vector_set__Set__i32):
            other = folly_sorted_vector_set__Set__i32(other)

        cdef shared_ptr[folly_sorted_vector_set[int32_t]] shretval = \
            make_shared[folly_sorted_vector_set[int32_t]]()
        for citem in deref((<folly_sorted_vector_set__Set__i32> self)._cpp_obj):
            if deref((<folly_sorted_vector_set__Set__i32> other)._cpp_obj).count(citem) > 0:
                deref(shretval).insert(citem)
        return folly_sorted_vector_set__Set__i32.create(shretval)

    def __sub__(self, other):
        if not isinstance(self, folly_sorted_vector_set__Set__i32):
            self = folly_sorted_vector_set__Set__i32(self)
        if not isinstance(other, folly_sorted_vector_set__Set__i32):
            other = folly_sorted_vector_set__Set__i32(other)

        cdef shared_ptr[folly_sorted_vector_set[int32_t]] shretval = \
            make_shared[folly_sorted_vector_set[int32_t]]()
        for citem in deref((<folly_sorted_vector_set__Set__i32> self)._cpp_obj):
            if deref((<folly_sorted_vector_set__Set__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return folly_sorted_vector_set__Set__i32.create(shretval)

    def __or__(self, other):
        if not isinstance(self, folly_sorted_vector_set__Set__i32):
            self = folly_sorted_vector_set__Set__i32(self)
        if not isinstance(other, folly_sorted_vector_set__Set__i32):
            other = folly_sorted_vector_set__Set__i32(other)

        cdef shared_ptr[folly_sorted_vector_set[int32_t]] shretval = \
            make_shared[folly_sorted_vector_set[int32_t]]()
        for citem in deref((<folly_sorted_vector_set__Set__i32> self)._cpp_obj):
                deref(shretval).insert(citem)
        for citem in deref((<folly_sorted_vector_set__Set__i32> other)._cpp_obj):
                deref(shretval).insert(citem)
        return folly_sorted_vector_set__Set__i32.create(shretval)

    def __xor__(self, other):
        if not isinstance(self, folly_sorted_vector_set__Set__i32):
            self = folly_sorted_vector_set__Set__i32(self)
        if not isinstance(other, folly_sorted_vector_set__Set__i32):
            other = folly_sorted_vector_set__Set__i32(other)

        cdef shared_ptr[folly_sorted_vector_set[int32_t]] shretval = \
            make_shared[folly_sorted_vector_set[int32_t]]()
        for citem in deref((<folly_sorted_vector_set__Set__i32> self)._cpp_obj):
            if deref((<folly_sorted_vector_set__Set__i32> other)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        for citem in deref((<folly_sorted_vector_set__Set__i32> other)._cpp_obj):
            if deref((<folly_sorted_vector_set__Set__i32> self)._cpp_obj).count(citem) == 0:
                deref(shretval).insert(citem)
        return folly_sorted_vector_set__Set__i32.create(shretval)

    def isdisjoint(self, other):
        return len(self & other) == 0

    def union(self, other):
        return self | other

    def intersection(self, other):
        return self & other

    def difference(self, other):
        return self - other

    def symmetric_difference(self, other):
        return self ^ other

    def issubset(self, other):
        return self <= other

    def issuperset(self, other):
        return self >= other


Set.register(folly_sorted_vector_set__Set__i32)

cdef class folly_sorted_vector_map__Map__i32_string:
    def __init__(self, items=None):
        if isinstance(items, folly_sorted_vector_map__Map__i32_string):
            self._cpp_obj = (<folly_sorted_vector_map__Map__i32_string> items)._cpp_obj
        else:
            self._cpp_obj = move(folly_sorted_vector_map__Map__i32_string._make_instance(items))

    @staticmethod
    cdef create(shared_ptr[folly_sorted_vector_map[int32_t,string]] c_items):
        inst = <folly_sorted_vector_map__Map__i32_string>folly_sorted_vector_map__Map__i32_string.__new__(folly_sorted_vector_map__Map__i32_string)
        inst._cpp_obj = c_items
        return inst

    @staticmethod
    cdef unique_ptr[folly_sorted_vector_map[int32_t,string]] _make_instance(object items) except *:
        cdef unique_ptr[folly_sorted_vector_map[int32_t,string]] c_inst = make_unique[folly_sorted_vector_map[int32_t,string]]()
        if items:
            for key, item in items.items():
                deref(c_inst).insert(cpair[int32_t,string](key,item.encode('UTF-8')))
        return move_unique(c_inst)

    def __getitem__(self, key):
        if not self:
            raise KeyError(f'{key}')
        cdef int32_t ckey = key
        cdef folly_sorted_vector_map[int32_t,string].iterator iter = deref(
            self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            raise KeyError(f'{key}')
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def __len__(self):
        return deref(self._cpp_obj).size()

    def __iter__(self):
        if not self:
            raise StopIteration
        cdef int32_t citem
        for pair in deref(self._cpp_obj):
            citem = pair.first
            yield citem

    def __richcmp__(self, other, op):
        cdef int cop = op
        if cop not in (2, 3):
            raise TypeError("unorderable types: {}, {}".format(type(self), type(other)))
        if not (isinstance(self, Mapping) and isinstance(other, Mapping)):
            return cop != 2
        if (len(self) != len(other)):
            return cop != 2

        for key in self:
            if key not in other:
                return cop != 2
            if other[key] != self[key]:
                return cop != 2

        return cop == 2

    def __hash__(self):
        if not self.__hash:
            self.__hash = hash(tuple(self.items()))
        return self.__hash

    def __repr__(self):
        if not self:
            return 'i{}'
        return f'i{{{", ".join(map(lambda i: f"{repr(i[0])}: {repr(i[1])}", self.items()))}}}'



    def __contains__(self, key):
        cdef int32_t ckey = key
        return deref(self._cpp_obj).count(ckey) > 0

    def get(self, key, default=None):
        if not self:
            return default
        cdef int32_t ckey = key
        cdef folly_sorted_vector_map[int32_t,string].iterator iter = \
            deref(self._cpp_obj).find(ckey)
        if iter == deref(self._cpp_obj).end():
            return default
        cdef string citem = deref(iter).second
        return bytes(citem).decode('UTF-8')

    def keys(self):
        return self.__iter__()

    def values(self):
        if not self:
            raise StopIteration
        cdef string citem
        for pair in deref(self._cpp_obj):
            citem = pair.second
            yield bytes(citem).decode('UTF-8')

    def items(self):
        if not self:
            raise StopIteration
        cdef int32_t ckey
        cdef string citem
        for pair in deref(self._cpp_obj):
            ckey = pair.first
            citem = pair.second

            yield (ckey, bytes(citem).decode('UTF-8'))



Mapping.register(folly_sorted_vector_map__Map__i32_string)


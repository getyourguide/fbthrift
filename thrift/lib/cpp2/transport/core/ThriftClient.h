/*
 * Copyright 2017-present Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <folly/io/IOBuf.h>
#include <folly/io/async/EventBase.h>
#include <stdint.h>
#include <thrift/lib/cpp2/transport/core/ClientConnectionIf.h>
#include <thrift/lib/cpp/protocol/TProtocolTypes.h>
#include <thrift/lib/cpp2/async/ClientChannel.h>
#include <map>
#include <memory>
#include <string>

namespace apache {
namespace thrift {

/**
 * This is the client side interface for Thrift RPCs.  You create an
 * object of this type and pass it as an argument to the constructor
 * of the client code generated by the Thrift compiler.
 *
 * ThriftClient objects are lightweight and you can create a new one
 * for each RPC.  However ThriftClient objects have minimal state and
 * multiple RPCs needing the same state may use the same ThriftClient
 * object at the same time.
 *
 * ThriftClient objects are provided a ClientConnectionIf object and
 * an event base as parameters during construction.
 *
 * The ClientConnectionIf object handles the underlying connection for
 * the RPCs.
 *
 * The event base is used to perform the callbacks for asynchronous
 * RPCs.  Callbacks for synchronous RPCs are always performed on the
 * event base of the underlying connection.
 *
 * The event base can be the same as that of the underlying connection
 * (and a special constructor is provided for this purpose).  Use this
 * only for synchronous RPCs.  While asynchronous RPCs will also work
 * in this case, we do not recommend using the event base of the
 * underling connection to perform callbacks for asynchronous RPCs.
 *
 * Synchronous RPCs may be performed from any thread except the one
 * that manages the underlying connection.
 *
 * Asynchronous RPCs may be performed from any thread.
 */
class ThriftClient : public ClientChannel {
 public:
  // Use "Ptr" instead of "unique_ptr<ThriftClient>".
  using Ptr =
      std::unique_ptr<ThriftClient, folly::DelayedDestruction::Destructor>;

  // Creates a ThriftClient object that uses "connection".  Callbacks
  // for asynchronous RPCs are run on "callbackEvb".  Callbacks for
  // synchronous RPCs are run on the event base of the connection.
  ThriftClient(
      std::shared_ptr<ClientConnectionIf> connection,
      folly::EventBase* callbackEvb);

  // Creates a ThriftClient object that uses "connection".  Callbacks
  // for all RPCs are run on the event base of the connection.
  explicit ThriftClient(std::shared_ptr<ClientConnectionIf> connection);

  ThriftClient(const ThriftClient&) = delete;
  ThriftClient& operator=(const ThriftClient&) = delete;

  void setProtocolId(uint16_t protocolId);

  // begin RequestChannel methods

  uint32_t sendRequestSync(
      RpcOptions&,
      std::unique_ptr<RequestCallback>,
      std::unique_ptr<apache::thrift::ContextStack>,
      std::unique_ptr<folly::IOBuf>,
      std::shared_ptr<apache::thrift::transport::THeader>) override;

  uint32_t sendRequest(
      RpcOptions& rpcOptions,
      std::unique_ptr<RequestCallback> cb,
      std::unique_ptr<ContextStack> ctx,
      std::unique_ptr<folly::IOBuf> buf,
      std::shared_ptr<apache::thrift::transport::THeader> header) override;

  uint32_t sendOnewayRequest(
      RpcOptions& rpcOptions,
      std::unique_ptr<RequestCallback> cb,
      std::unique_ptr<ContextStack> ctx,
      std::unique_ptr<folly::IOBuf> buf,
      std::shared_ptr<apache::thrift::transport::THeader> header) override;

  folly::EventBase* getEventBase() const override;

  uint16_t getProtocolId() override;

  void setCloseCallback(CloseCallback* cb) override;

  // end RequestChannel methods

  // begin ClientChannel methods

  // These methods are delegated to the connection object.  Given that
  // connection objects may be shared by multiple ThriftClient
  // objects, calls to these methods will affect all these
  // ThriftClient objects.  Therefore, these methods should only be
  // called by frameworks that manage all the ThriftClient objects.
  //
  // TODO: Refactor this to be cleaner.

  apache::thrift::async::TAsyncTransport* getTransport() override;
  bool good() override;
  SaturationStatus getSaturationStatus() override;
  void attachEventBase(folly::EventBase* eventBase) override;
  void detachEventBase() override;
  bool isDetachable() override;
  bool isSecurityActive() override;
  uint32_t getTimeout() override;
  void setTimeout(uint32_t ms) override;
  void closeNow() override;
  CLIENT_TYPE getClientType() override;

  // end ClientChannel methods

 private:
  std::shared_ptr<ClientConnectionIf> connection_;
  folly::EventBase* callbackEvb_;
  uint16_t protocolId_{apache::thrift::protocol::T_COMPACT_PROTOCOL};

  // Destructor is private because this class inherits from
  // folly:DelayedDestruction.
  virtual ~ThriftClient() = default;

  uint32_t sendRequestHelper(
      RpcOptions& rpcOptions,
      bool oneway,
      std::unique_ptr<RequestCallback> cb,
      std::unique_ptr<ContextStack> ctx,
      std::unique_ptr<folly::IOBuf> buf,
      std::shared_ptr<apache::thrift::transport::THeader> header,
      folly::EventBase* callbackEvb);

  std::unique_ptr<std::map<std::string, std::string>> buildHeaders(
      apache::thrift::transport::THeader* header,
      RpcOptions& rpcOptions);
};

} // namespace thrift
} // namespace apache
